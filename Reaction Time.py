# -*- coding: utf-8 -*-
"""Reaction Time

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/12c-49PQh00HLkaIHueuE3LA_yuH1LFIR
"""

import scipy.io
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import groupby
from operator import itemgetter
from scipy.signal import savgol_filter
from scipy.io import loadmat

"""#Reaction time"""

final_df = pd.read_csv("final_df1.csv") #cleaned and merged data fram first fixation to action

final_df

#Apply log 10 format for firt_fix_to_action
final_df["log10_reaction_time_ms"] = np.log10(final_df["reaction_time_ms"] + 1)

final = ['session', 'trial', 'valence','side', 'condition', 'reaction_time_ms', 'log10_reaction_time_ms']

# Yeni DataFrame oluştur
rt_final = final_df[final].copy()

# Drop any row that contains a NaN value
rt_final = rt_final.dropna().reset_index(drop=True)

rt_final

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(rt_final['reaction_time_ms'], bins=50, kde=True, color='blue')
plt.title("Reaction Time Distribution")
plt.xlabel("Reaction Time (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(rt_final['log10_reaction_time_ms'], bins=50, kde=True, color='green')
plt.title("Log10 Reaction Time Distribution")
plt.xlabel("Log10(Reaction Time)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

# Effective coding

# Apply effect coding
rt_final["valence"] = rt_final["valence"].map({
    0 : -1, #negative
    1 : 1 #positive
})

rt_final["condition"] = rt_final["condition"].map({
    "incongruent": -1,
    "congruent": 1
})

rt_final["side"] = rt_final["side"].map({
    "left": -1,
    "right": 1
})

#Clean nan values

# Drop any row that contains a NaN value
rt_ready = rt_final.dropna().reset_index(drop=True)

# Optional: display result
rt_ready

# --- Add Participant column ---
sessions_per_participant = 2  # 2 session = 1 participant
ffd_final['participant'] = ((ffd_final['session'] - 1) // sessions_per_participant) + 1


new_records = []
num_participants = ffd_final['participant'].nunique()

for pid in range(1, num_participants + 1):

    participant_data = ffd_final[ffd_final['participant'] == pid]

    # Sessionları and trial
    participant_data = participant_data.sort_values(by=['session', 'trial']).reset_index(drop=True)


    participant_data['trials'] = range(1, len(participant_data) + 1)

    new_records.append(participant_data)

rt_df = pd.concat(new_records, ignore_index=True)

final_df = rt_df[["participant","trials","reaction_time_ms","log10_reaction_time_ms", "side", "valence","condition"]].copy()

final_df

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(final_df['reaction_time_ms'], bins=50, kde=True, color='blue')
plt.title("Reaction Time Distribution")
plt.xlabel("Reaction Time (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(final_df['log10_reaction_time_ms'], bins=50, kde=True, color='green')
plt.title("Log10 Reaction Time Distribution")
plt.xlabel("Log10(Reaction Time)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

sns.barplot(data=final_df, x="valence", y="reaction_time_ms", ci="sd")
plt.title("RT by Emotional Valence")
plt.xlabel("Emotional Valence (-1: Negative, 1: Positive)")
plt.ylabel("RT (ms)")
plt.show()

sns.barplot(data=final_df, x="side", y="reaction_time_ms", ci="sd")
plt.title("RT by Side ")
plt.xlabel("Side (-1: left, 1: right)")
plt.ylabel("RT (ms)")
plt.show()

sns.barplot(data=final_df, x="condition", y="reaction_time_ms", ci="sd")
plt.title("RT by condition ")
plt.xlabel("Condition (-1: incongruent, 1: congruent)")
plt.ylabel("RT (ms)")
plt.show()

groups = {}
for side_label, side_val in [("Right", 1), ("Left", -1)]:
    for valence_label, valence_val in [("Positive", 1), ("Negative", -1)]:
        for cond_label, cond_val in [("Congruent", 1), ("Incongruent", -1)]:
            group_name = f"{side_label}-{valence_label}-{cond_label}"
            condition_mask = (
                (rt_ready["side"] == side_val) &
                (rt_ready["valence"] == valence_val) &
                (rt_ready["condition"] == cond_val)
            )
            groups[group_name] = condition_mask

# Mean and Std
summary_df = pd.DataFrame(columns=["Group", "Mean", "Std", "Count"])

for name, mask in groups.items():
    subset = rt_ready.loc[mask, "reaction_time_ms"]
    mean_val = subset.mean()
    std_val = subset.std()
    summary_df = pd.concat([summary_df, pd.DataFrame({
        "Group": [name],
        "Mean": [mean_val],
        "Std": [std_val]
    })], ignore_index=True)

# Results
print(summary_df)

rt_ready_plot = final_df.copy()
rt_ready_plot["valence"] = rt_ready_plot["valence"].map({-1: "Negative", 1: "Positive"})
rt_ready_plot["side"] = rt_ready_plot["side"].map({-1: "Left", 1: "Right"})
rt_ready_plot["condition"] = rt_ready_plot["condition"].map({-1: "Incongruent", 1: "Congruent"})

# Violin Plot: valence x log10_fta, hue = side, col = condition
g = sns.catplot(
    data=rt_ready_plot,
    x="valence", y="reaction_time_ms",
    hue="side", col="condition",
    kind="violin",
    split=True, inner="quartile",
    palette={"Left": "#1f77b4", "Right": "#ff7f0e"},
    height=5, aspect=1
)

g.set_axis_labels("Valence", " Reaction Time")
g.set_titles("Condition: {col_name}")
g.add_legend(title="Side")
plt.suptitle("Violin Plot of Reaction Time(ms))", fontsize=14, y=1.05)
plt.tight_layout()
plt.show()

import statsmodels.api as sm
from statsmodels.formula.api import mixedlm

log10_model = mixedlm(
    "log10_reaction_time_ms ~ side * valence * condition",
    data=final_df,
    groups=final_df["participant"],
    re_formula="~side"
)

log10_result = log10_model.fit(reml=False)
print(log10_result.summary())
print(f"\nAIC: {log10_result.aic:.2f}")
print(f"BIC: {log10_result.bic:.2f}")

log10_residuals = log10_result.resid
log10_fitted = log10_result.fittedvalues

# Histogram
sns.histplot(log10_residuals, kde=True, bins=50)
plt.title('Distribution of Residuals (Log10 Model)')
plt.xlabel('Residuals')
plt.tight_layout()
plt.show()

# Q-Q Plot
sm.qqplot(log10_residuals, line='s')
plt.title('Q-Q Plot of Residuals (Log10 Model)')
plt.tight_layout()
plt.show()
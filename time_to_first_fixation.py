# -*- coding: utf-8 -*-
"""Time to First Fixation

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1-a4w8sWigjy8ovRjesG0JNWIlETLQ4jA

##Import Libraries
"""

import scipy.io
import scipy.io as sio
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import groupby
from operator import itemgetter
from scipy.signal import savgol_filter
from scipy.io import loadmat

"""##Import Data"""

behavioralreactiontime = scipy.io.loadmat('behavioralReactionTime.mat')['reactionTime']
rt_time = pd.DataFrame(behavioralreactiontime)

rt_time

framecolor = scipy.io.loadmat('/content/frameColor.mat')['frameColor']
framecolor_df = pd.DataFrame(framecolor)
print(framecolor.shape)

frameside = scipy.io.loadmat('/content/frameSide.mat')['frameSide']
frameside_df = pd.DataFrame(frameside)
print(frameside_df.shape)

picturenegative = scipy.io.loadmat('/content/pictureSequenceNegative.mat')['pictureSequenceNegative']
picture_negative = pd.DataFrame(picturenegative)

picturepositive = scipy.io.loadmat('/content/pictureSequencePositive.mat')['pictureSequencePositive']
picture_positive = pd.DataFrame(picturepositive)

picturetimemat = scipy.io.loadmat('/content/pictureTimeMat.mat')['pictureTimeMat']
picture_time = pd.DataFrame(picturetimemat)

side = scipy.io.loadmat('/content/sidePositive.mat')['sidePositive']
side_df = pd.DataFrame(side)

valence = scipy.io.loadmat('/content/valenceLooked.mat')['valence']
valence_df = pd.DataFrame(valence)
print(valence_df.shape)

reactiontype = scipy.io.loadmat('/content/reactionType.mat')['actualReaction']
reactiontype_df = pd.DataFrame(reactiontype)

frametime = scipy.io.loadmat('/content/adjusted_frameTime.mat')['adjusted_frameTime'] #48x130
frame_time = pd.DataFrame(frametime)
print(frame_time.shape)

fixationCrossTime = scipy.io.loadmat('/content/resultMatrix.mat')['resultMatrix']
fixationcross_time = pd.DataFrame(fixationCrossTime)
fixationcrosstime = pd.DataFrame(fixationcross_time)

fixationcrosstime

#trialtime = scipy.io.loadmat('/content/trialTime.mat')['trialTime'] #1x130

m = loadmat('trialTime.mat', squeeze_me=True)
raw = m['trialTime']


session_list = []
for i in range(raw.size):
    arr = np.array(raw[i]).ravel()
    if len(arr) < 48:
        arr = np.pad(arr, (0, 48 - len(arr)), constant_values=np.nan)
    session_list.append(arr)


time_data = np.column_stack(session_list)  # (48, 130)

print(time_data.shape)   # (48, 130)

#xposition_data = sio.loadmat('xPositionData.mat')['xPosition']  # (1, 130)

m = sio.loadmat('xPositionData.mat', squeeze_me=True)
raw_x = m['xPosition']  # (1, 130) cell array

xposition_list = []
for i in range(raw_x.size):
    arr = np.array(raw_x[i]).ravel()
    if len(arr) < 48:
        arr = np.pad(arr, (0, 48 - len(arr)), constant_values=np.nan)
    xposition_list.append(arr)

# 3) 48x130 numpy array
eye_data = np.column_stack(xposition_list)
print(eye_data.shape)  # (48 trial, 130 session)

"""##Defining Threshold"""

#middle of the screen 960

lower_threshold = 860
upper_threshold = 1060

s = 100    # session index (0–129)
t = 11    # trial index       (0–47)

eye_vec  = eye_data[t, s]
time_vec = time_data[t, s]

plt.figure(figsize=(8,6))
plt.plot(time_vec, eye_vec, label='X-Position', color='blue')
plt.axhline(lower_threshold, color='red', linestyle='--', label='Lower Threshold')
plt.axhline(upper_threshold, color='red', linestyle='--', label='Upper Threshold')

plt.xlabel('Time (ms)')
plt.ylabel('X Position (px)')
plt.title(f'Session {s+1}, Trial {t+1}')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

s = 2    # session index (0–129)
t = 11    # trial index       (0–)

#
eye_vec     = eye_data[t, s]    # X-pozisyon
time_vec    = time_data[t, s]   # (ms)
frame_onset = frame_time.iloc[t, s]  # frame onset

# plot
plt.figure(figsize=(8,6))
plt.plot(time_vec, eye_vec, label='X-Position',  color='blue')


plt.axhline(lower_threshold, color='red',   linestyle='--', label='Lower Threshold')
plt.axhline(upper_threshold, color='red',   linestyle='--', label='Upper Threshold')

# frame onset
plt.axvline(frame_onset, color='green', linestyle='--', label='Frame Onset')


plt.xlabel('Time (ms)')
plt.ylabel('X Position (px)')
plt.title(f'Session {s+1}, Trial {t+1}')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""#First Fixation Calculation"""

# --- Parameters ---
velocity_threshold = 12       # px/ms
stability_threshold = 30      # px
window_size = 20              #
screen_center = 960
margin = 100
lower_threshold = screen_center - margin
upper_threshold = screen_center + margin

n_trials, n_sessions = eye_data.shape
fixation_start_times = np.full((n_trials, n_sessions), np.nan)
fixation_end_times   = np.full((n_trials, n_sessions), np.nan)
missing_fixations    = []

for s in range(n_sessions):        # 0…129 (session)
    for t in range(n_trials):      # 0…47 (trial)
        x = eye_data[t, s]         # (X-Position)
        times = time_data[t, s]    # (time)
        onset_time = picture_time.iloc[t, s]  # Picture onset


        if x is None or times is None or np.isnan(onset_time):
            missing_fixations.append((s, t))
            continue


        onset_idx = np.nanargmin(np.abs(times - onset_time))

        vel = np.abs(np.diff(x))
        saccade_detected = False
        first_fix_start = None

        # --- Find first fixation ---
        for i in range(onset_idx + 20, len(x) - window_size):
            if not saccade_detected:

                if vel[i-1] > velocity_threshold and (x[i] < lower_threshold or x[i] > upper_threshold):
                    saccade_detected = True
                continue

            # Stability
            window = x[i : i + window_size]
            vel_window = vel[i : i + window_size - 1]
            if (np.nanmax(window) - np.nanmin(window) <= stability_threshold) and np.all(vel_window < velocity_threshold):
                if x[i] < lower_threshold or x[i] > upper_threshold:
                    first_fix_start = times[i + window_size // 2]
                    break

        if first_fix_start is None:
            missing_fixations.append((s, t))
            continue

        # --- Fixation end ---
        idx0 = np.nanargmin(np.abs(times - first_fix_start))
        direction_left = x[idx0] < screen_center
        last_stable = None
        first_fix_end = None

        for j in range(idx0 + window_size, len(x)):
            win = x[max(0, j-window_size):j]
            vel_win = vel[max(0, j-window_size):j-1]
            if len(win) == window_size and (np.nanmax(win) - np.nanmin(win) <= stability_threshold):
                last_stable = times[j - window_size // 2]

            if np.any(vel_win > velocity_threshold) and (
                (direction_left and x[j] > lower_threshold) or
                (not direction_left and x[j] < upper_threshold)
            ):
                first_fix_end = last_stable if last_stable is not None else times[j-1]
                break

        if first_fix_end is None:
            first_fix_end = times[-1]

        # --- Save ---
        fixation_start_times[t, s] = first_fix_start
        fixation_end_times[t, s]   = first_fix_end

# --- .mat ---
sio.savemat("fixationStartTimes_strict_48x130.mat", {"fixationStartTimes": fixation_start_times})
sio.savemat("fixationEndTimes_strict_48x130.mat",   {"fixationEndTimes":   fixation_end_times})

print(f"Total fixation not found: {len(missing_fixations)}")

missing_readable = [(s + 1, t + 1) for t, s in missing_fixations]
missing_df = pd.DataFrame(missing_readable, columns=['Session', 'Trial'])

missing_df

def plot_first_fixation(session_number, trial_number):
    """
    session_number: 1-based (1…130)
    trial_number:   1-based (1…48)
    eye_data:       np.array shape=(48,130)
    time_data:      np.array shape=(48,130)
    picture_time:   pd.DataFrame shape=(48,130)
    fixation_start_times, fixation_end_times: np.array shape=(48,130)
    """
    # Thresholdları
    lower_threshold = screen_center - margin
    upper_threshold = screen_center + margin

    # Python 0-based index
    s = session_number - 1
    t = trial_number  - 1

    # data
    x_data = eye_data[t, s]
    t_data = time_data[t, s]
    frame_onset = frame_time.iloc[t, s]
    fix_start = fixation_start_times[t, s]
    fix_end   = fixation_end_times[t, s]

    plt.figure(figsize=(12, 5))
    plt.plot(t_data, x_data, color='black', label='X Position')

    # Picture onset
    if not np.isnan(frame_onset):
        plt.axvline(frame_onset, color='green', linestyle='--', label='Frame Onset')

    # Threshold
    plt.axhline(lower_threshold, color='red', linestyle='--', label='Lower Threshold')
    plt.axhline(upper_threshold, color='red', linestyle='--', label='Upper Threshold')

    # First fixation
    if not np.isnan(fix_start) and not np.isnan(fix_end):

        si = np.nanargmin(np.abs(t_data - fix_start))
        ei = np.nanargmin(np.abs(t_data - fix_end))

        plt.plot(t_data[si:ei+1],
                 x_data[si:ei+1],
                 color='blue', linewidth=2,
                 label='First Fixation')

        plt.axvline(fix_start, color='purple', linestyle='--', label='Fixation Start')
        plt.axvline(fix_end,   color='orange', linestyle='--', label='Fixation End')
        title = f"Session {session_number}, Trial {trial_number} – First Fixation"
    else:
        title = f"Session {session_number}, Trial {trial_number} – No fixation detected"

    plt.title(title)
    plt.xlabel("Time (ms)")
    plt.ylabel("X Position (pixels)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

plot_first_fixation(session_number= 3, trial_number=12)

if 'fixation_start_times' not in locals() or 'fixation_end_times' not in locals():
    print("Error: The string 'fixation_start_times' or 'fixation_end_times' was not found.")
    print("Run this code after the fixation detection loop has run.")
else:
    # Get the dimensions directly from the shape of the 'fixation_start_times' array
    num_trials, num_sessions = fixation_start_times.shape  # 48 x 130

    data_for_df = []

    # Loop for each session and each trial
    for trial_idx in range(num_trials):
        for session_idx in range(num_sessions):
            # Get fixation start time for specific session and trial
            start_time = fixation_start_times[trial_idx, session_idx]
            end_time = fixation_end_times[trial_idx, session_idx]

            # Add data to the list as a dictionary (1-based numbering)
            data_for_df.append({
                'session': session_idx + 1,
                'trial': trial_idx + 1,
                'fixation_start_time': start_time,
                'fixation_end_time': end_time
            })

    # --- 2.Create DataFrame ---
    fixation_times_df = pd.DataFrame(data_for_df)

fixation_times_df

"""#Time to First Fixation"""

#Step 1
# calculate first fixation as  ms for that we have to take picture onset as a startes point. Formula = first fixation - picture onset
#Step 2
# calculate fixation end time
#Step 3
# calculate frame onset as a ms. formula = frame onset - picture onset

records = []

for _, row in fixation_times_df.iterrows():
    sid = int(row['session'])               # 1-based session
    trial = int(row['trial'])               # 1-based trial
    fix_start = row['fixation_start_time']
    fix_end = row['fixation_end_time']

    # onset times with 0-based indexing
    frame_onset   = frame_time.iloc[trial-1, sid-1]
    picture_onset = picture_time.iloc[trial-1, sid-1]

    # If there is fixation first_fix_ms (fix-start – picture-onset)
    if not np.isnan(fix_start):
        first_fix_ms = fix_start - picture_onset
    else:
        first_fix_ms = np.nan

    #fixation end
    if not np.isnan(fix_end) and not np.isnan(picture_onset):
        fixation_end_ms = fix_end - picture_onset
    else:
        fixation_end_ms = np.nan

    # picture – frame differences
    if not np.isnan(picture_onset) and not np.isnan(frame_onset):
        frame_time_ms = frame_onset - picture_onset
    else:
        frame_time_ms = np.nan

    records.append({
        'session': sid,
        'trial': trial,
        'picture_onset_time': picture_onset,
        'frame_onset_time':   frame_onset,
        'fixation_start_time': fix_start,
        'fixation_end_time':   fix_end,
        'first_fix_ms':        first_fix_ms,
        'fixation_end_ms': fixation_end_ms,
        'frame_time_ms':       frame_time_ms
    })


first_fix_ms_df = pd.DataFrame(records)

first_fix_ms_df

#Step 4
# convert reaction time sec to ms

df = rt_time.reset_index().rename(columns={'index': 'trial'})


long_df = df.melt(id_vars='trial',
                  var_name='session',
                  value_name='reaction_time_sec')


long_df['trial'] = long_df['trial'] + 1
long_df['session'] = long_df['session'].astype(int) + 1


reactiontime_df = (
    long_df[['session', 'trial', 'reaction_time_sec']]
    .assign(reaction_time_ms=lambda df: (df.reaction_time_sec * 1000).round(1))
)

reactiontime_df

#Step 5
# Combining reaction time and fixation ms and frame ms data

fix_cols = ['session', 'trial', 'first_fix_ms','fixation_end_ms', 'frame_time_ms']
rt_cols  = ['session', 'trial', 'reaction_time_ms']

# 2) merge
final_df = (
    first_fix_ms_df[fix_cols]
    .merge(
        reactiontime_df[rt_cols],
        on=['session', 'trial'],
        how='inner'
    )
)

# 3) RT
final_df['reaction_time_real_ms'] = final_df['frame_time_ms'] + final_df['reaction_time_ms']


final_df = final_df[['session', 'trial',
                     'first_fix_ms','fixation_end_ms',
                     'frame_time_ms', 'reaction_time_ms',
                     'reaction_time_real_ms']]

final_df

#Step 6
# add valence, side, condition veribles

reaction_long = (
    reactiontype_df
      .reset_index()
      .rename(columns={'index':'trial0'})
      .melt(
        id_vars='trial0',
        var_name='session0',
        value_name='reaction_type'
      )
)
reaction_long['trial']   = reaction_long['trial0'].astype(int) + 1
reaction_long['session'] = reaction_long['session0'].astype(int) + 1
reaction_long['reaction_type'] = reaction_long['reaction_type'].apply(
    lambda x: x[0] if isinstance(x, (list, np.ndarray)) and len(x) > 0 else np.nan
)
reaction_long = reaction_long[['session', 'trial', 'reaction_type']]

# --- 2) valence_df ---
valence_long = (
    valence_df
      .reset_index()
      .rename(columns={'index':'trial0'})
      .melt(
        id_vars='trial0',
        var_name='session0',
        value_name='valence'
      )
)
valence_long['trial']   = valence_long['trial0'].astype(int) + 1
valence_long['session'] = valence_long['session0'].astype(int) + 1
valence_long = valence_long[['session', 'trial', 'valence']]

# --- 3) side_looked ---
side_records = []

for _, row in fixation_times_df.iterrows():
    sid = int(row['session'])
    trial = int(row['trial'])
    fix_start = row['fixation_start_time']

    side_looked = np.nan
    if not np.isnan(fix_start):
        eye_vec = eye_data[trial-1, sid-1]
        time_vec = time_data[trial-1, sid-1]
        if eye_vec is not None and time_vec is not None:
            fix_start_idx = np.nanargmin(np.abs(time_vec - fix_start))
            x_at_fixation = eye_vec[fix_start_idx]
            if x_at_fixation < screen_center:
                side_looked = 'left'
            elif x_at_fixation > screen_center:
                side_looked = 'right'

    side_records.append({
        'session': sid,
        'trial': trial,
        'side': side_looked
    })

side_long = pd.DataFrame(side_records)

# --- 4) final_df ---
final_df = (
    final_df
      .merge(valence_long,  on=['session', 'trial'], how='left')
      .merge(reaction_long, on=['session', 'trial'], how='left')
      .merge(side_long,     on=['session', 'trial'], how='left')
)

# --- 5) condition ---
def assign_condition(row):
    if pd.isna(row['valence']) or pd.isna(row['reaction_type']):
        return np.nan
    # positive (1) pull = congruent
    if row['valence'] == 1:
        return 'congruent' if row['reaction_type'] == 'pull' else 'incongruent'
    # negative (0) push = congruent
    if row['valence'] == 0:
        return 'congruent' if row['reaction_type'] == 'push' else 'incongruent'
    return np.nan

# for implicit task
#if pd.isna(row['frame_color']) or pd.isna(row['reaction_type']):
        #return np.nan
    # ORANGE (0) → Pull = congruent, Push = incongruent
    #if row['frame_color'] == 0:
        #return 'congruent' if row['reaction_type'] == 'pull' else 'incongruent'
    # BLUE (1) → Push = congruent, Pull = incongruent
    #if row['frame_color'] == 1:
        #return 'congruent' if row['reaction_type'] == 'push' else 'incongruent'
    #return np.nan

final_df['condition'] = final_df.apply(assign_condition, axis=1)

final_df

def plot_tff(session, trial):
    """
    session: 1-based index (1–130)
    trial:   1-based index (1–48)
    """
    s_idx = session - 1
    t_idx = trial - 1

    # Gaze and time
    x_data = eye_data[t_idx, s_idx]
    t_data = time_data[t_idx, s_idx]
    if x_data is None or t_data is None:
        print("No gaze data found for this session/trial.")
        return


    frame_onset = frame_time.iloc[t_idx, s_idx]
    fix_start = fixation_start_times[t_idx, s_idx]
    fix_end = fixation_end_times[t_idx, s_idx]

    # Reaction time (
    reaction_row = final_df[
        (final_df['session'] == session) &
        (final_df['trial'] == trial)
    ]
    if not reaction_row.empty:
        behavioral_reaction_time = frame_onset + reaction_row['reaction_time_ms'].values[0]
    else:
        behavioral_reaction_time = None

    # Plot
    plt.figure(figsize=(10, 5))
    plt.plot(t_data, x_data, color='black', label='X Position')


    if not np.isnan(fix_start) and not np.isnan(fix_end):
        s_idx_fix = np.nanargmin(np.abs(t_data - fix_start))
        e_idx_fix = np.nanargmin(np.abs(t_data - fix_end))
        plt.plot(t_data[s_idx_fix:e_idx_fix+1], x_data[s_idx_fix:e_idx_fix+1],
                 color='blue', linewidth=2, label='First Fixation')

    # Thresholds
    plt.axhline(lower_threshold, color='red', linestyle='--', label='Lower Threshold')
    plt.axhline(upper_threshold, color='red', linestyle='--', label='Upper Threshold')

    # Frame onset
    plt.axvline(frame_onset, color='green', linestyle='--', label='Frame Onset')

    # Fixation start ve end
    if not np.isnan(fix_start):
        plt.axvline(fix_start, color='purple', linestyle='--', label='Fixation Start')
    if not np.isnan(fix_end):
        plt.axvline(fix_end, color='orange', linestyle='--', label='Fixation End')

    # Behavioral reaction time
    if behavioral_reaction_time is not None and not np.isnan(behavioral_reaction_time):
        plt.axvline(behavioral_reaction_time, color='blue', linestyle='-', label='Behavioral Reaction')

    # Başlık ve etiketler
    plt.title(f'Session {session}, Trial {trial}')
    plt.xlabel('Time (ms)')
    plt.ylabel('X Position (pixels)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

plot_tff(1, 1)

#data elemenating depents on experiment

#1. elemenate invalid sessions 69, 70, 107, 108 for exp 1

target_sessions = [69, 70, 107, 108]

# apply NaN
final_df.loc[final_df['session'].isin(target_sessions), :] = np.nan

#2. elemenate fixation start after reaction time

# Fixation end'in reaction time'dan sonra bittiği satırlar
negatives1 = final_df[final_df['reaction_time_real_ms'] - final_df['first_fix_ms'] < 0]

print(f"Toplam {len(negatives1)} trial fixation start, finished AFTER the reaction.")

neg_mask1 = final_df['reaction_time_real_ms'] - final_df['first_fix_ms'] < 0
final_df.loc[neg_mask1, :] = np.nan

print(f"Toplam {neg_mask1.sum()} Trial fixation start finished AFTER reaction and NaN was made.")

#3. elemenate fixation end trials continuing after the reaction

negatives2 = final_df[final_df['reaction_time_real_ms'] - final_df['fixation_end_ms'] < 0]

print(f"Toplam {len(negatives2)} trial fixation END, finished AFTER reaction.")

negatives2

plot_tff(60, 1)

# make nan first fixations end after reaction time

neg_mask2 = final_df['reaction_time_real_ms'] - final_df['fixation_end_ms'] < 0


final_df.loc[neg_mask2, :] = np.nan

# 3) Kontrol: Kaç satır NaN oldu
print(f"Toplam {neg_mask2.sum()} trial fixation END finished AFTER the reaction and NaN was made.")

final = ['session', 'trial', 'first_fix_ms', 'valence','side']

# Yeni DataFrame oluştur
tff_final = final_df[final].copy()

tff_final

#Apply log 10 format for first_fix_ms
tff_final["log10_first_fix_ms"] = np.log10(tff_final["first_fix_ms"] + 1)

tff_final

# Drop any row that contains a NaN value
tff_final = tff_final.dropna().reset_index(drop=True)

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(tff_final['first_fix_ms'], bins=50, kde=True, color='blue')
plt.title("Time to First Fixation Distribution")
plt.xlabel("TFF (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(tff_final['log10_first_fix_ms'], bins=50, kde=True, color='green')
plt.title("Log10 Time to First Fixation Distribution")
plt.xlabel("Log10(TFF)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

mask_2000 = (tff_final['first_fix_ms'] > 2000) #frame matching problems

mask_combined = mask_2000


tff_final.loc[mask_combined, ['first_fix_ms', 'log10_first_fix_ms']] = np.nan

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(tff_final['first_fix_ms'], bins=50, kde=True, color='blue')
plt.title("Time to First Fixation Distribution")
plt.xlabel("TFF (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(tff_final['log10_first_fix_ms'], bins=50, kde=True, color='green')
plt.title("Log10 Time to First Fixation Distribution")
plt.xlabel("Log10(TFF)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

tff_final

# --- Add Participant column ---
sessions_per_participant = 2  # 2 session = 1 participant
ffd_final['participant'] = ((ffd_final['session'] - 1) // sessions_per_participant) + 1


new_records = []
num_participants = ffd_final['participant'].nunique()

for pid in range(1, num_participants + 1):

    participant_data = ffd_final[ffd_final['participant'] == pid]

    # Sessionları and trial
    participant_data = participant_data.sort_values(by=['session', 'trial']).reset_index(drop=True)


    participant_data['trials'] = range(1, len(participant_data) + 1)

    new_records.append(participant_data)


ffd_df = pd.concat(new_records, ignore_index=True)

tff_df_final = tff_df[["participant","trials","first_fix_ms","log10_first_fix_ms", "side", "valence"]].copy()

tff_df_final

# Effective coding

# Apply effect coding
tff_df_final["valence"] = tff_df_final["valence"].map({
    0 : -1, #negative
    1 : 1 #positive
})

tff_df_final["side"] = tff_df_final["side"].map({
    "left": -1,
    "right": 1
})

# Drop any row that contains a NaN value
tff_df_final = tff_df_final.dropna().reset_index(drop=True)

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(tff_df_final['first_fix_ms'], bins=50, kde=True, color='blue')
plt.title("Time to First Fixation Distribution")
plt.xlabel("TFF (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(tff_df_final['log10_first_fix_ms'], bins=50, kde=True, color='green')
plt.title("Log10 Time to First Fixation Distribution")
plt.xlabel("Log10(TFF)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

sns.barplot(data=tff_df_final, x="valence", y="first_fix_ms", ci="sd")
plt.title("TFF by Emotional Valence")
plt.xlabel("Emotional Valence (-1: Negative, 1: Positive)")
plt.ylabel("Time to First Fixation (ms)")
plt.show()

sns.barplot(data=tff_df_final, x="side", y="first_fix_ms", ci="sd")
plt.title("TFF by Side ")
plt.xlabel("Side (-1: left, 1: right)")
plt.ylabel("Time to First Fixation (ms)")
plt.show()

tff_df_final['Valence_Label'] = tff_df_final['valence'].map({-1: 'Negative', 1: 'Positive'})
tff_df_final['Side_Label'] = tff_df_final['side'].map({-1: 'Left', 1: 'Right'})


sns.set_style("whitegrid")
plt.figure(figsize=(7, 6))


sns.barplot(
    data=tff_df_final,
    x="Valence_Label",
    y="first_fix_ms",
    hue="Side_Label",
    ci="sd"
)

plt.title("TFF by Emotional Valence and First Fixation Side", fontsize=14, weight='bold', pad=15)
plt.xlabel("Emotional Valence", fontsize=12)
plt.ylabel("Time to First Fixation (ms)", fontsize=12)
plt.legend(title="First Fixation Side")
plt.tight_layout()
plt.show()

groups = {
    "Right-Positive": (tff_df_final["side"] == 1) & (tff_df_final["valence"] == 1),
    "Right-Negative": (tff_df_final["side"] == 1) & (tff_df_final["valence"] == -1),
    "Left-Positive": (tff_df_final["side"] == -1) & (tff_df_final["valence"] == 1),
    "Left-Negative": (tff_df_final["side"] == -1) & (tff_df_final["valence"] == -1)
}


summary_df = pd.DataFrame(columns=["Group", "Mean", "Std"])


for name, condition in groups.items():
    subset = tff_df_final.loc[condition, "first_fix_ms"]
    mean_val = subset.mean()
    std_val = subset.std()
    summary_df = pd.concat([summary_df, pd.DataFrame({
        "Group": [name],
        "Mean": [mean_val],
        "Std": [std_val]
    })], ignore_index=True)


print(summary_df)

"""#LMM"""

!pip install statsmodels pandas

import statsmodels.api as sm
from statsmodels.formula.api import mixedlm

log10_model = mixedlm("log10_first_fix_ms ~ valence + side",
                      data=tff_df_final,
                      groups=tff_df_final["participant"],
                      re_formula="~side")

log10_result = log10_model.fit(reml=False)

print(log10_result.summary())
print(f"\nAIC: {log10_result.aic:.2f}")
print(f"BIC: {log10_result.bic:.2f}")

log10_residuals = log10_result.resid
log10_fitted = log10_result.fittedvalues

# Histogram
sns.histplot(log10_residuals, kde=True, bins=30)
plt.title('Distribution of Residuals (Log10 Model)')
plt.xlabel('Residuals')
plt.tight_layout()
plt.show()

# Q-Q Plot
sm.qqplot(log10_residuals, line='s')
plt.title('Q-Q Plot of Residuals (Log10 Model)')
plt.tight_layout()
plt.show()


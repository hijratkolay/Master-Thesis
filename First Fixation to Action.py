# -*- coding: utf-8 -*-
"""First Fixation to Action

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nlK0BuYvcefigXOp_dAV5O1vEzCY57ch

##Import Libraries
"""

import scipy.io
import scipy.io as sio
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import seaborn as sns
from itertools import groupby
from operator import itemgetter
from scipy.signal import savgol_filter
from scipy.io import loadmat

"""##Import Data"""

behavioralreactiontime = scipy.io.loadmat('behavioralReactionTime.mat')['reactionTime']
rt_time = pd.DataFrame(behavioralreactiontime)

rt_time

framecolor = scipy.io.loadmat('/content/frameColor.mat')['frameColor']
framecolor_df = pd.DataFrame(framecolor)
print(framecolor.shape)

frameside = scipy.io.loadmat('/content/frameSide.mat')['frameSide']
frameside_df = pd.DataFrame(frameside)
print(frameside_df.shape)

picturenegative = scipy.io.loadmat('/content/pictureSequenceNegative.mat')['pictureSequenceNegative']
picture_negative = pd.DataFrame(picturenegative)

picturepositive = scipy.io.loadmat('/content/pictureSequencePositive.mat')['pictureSequencePositive']
picture_positive = pd.DataFrame(picturepositive)

picturetimemat = scipy.io.loadmat('/content/pictureTimeMat.mat')['pictureTimeMat']
picture_time = pd.DataFrame(picturetimemat)

side = scipy.io.loadmat('/content/sidePositive.mat')['sidePositive']
side_df = pd.DataFrame(side)

valence = scipy.io.loadmat('/content/valenceLooked.mat')['valence']
valence_df = pd.DataFrame(valence)
print(valence_df.shape)

reactiontype = scipy.io.loadmat('/content/reactionType.mat')['actualReaction']
reactiontype_df = pd.DataFrame(reactiontype)

frametime = scipy.io.loadmat('/content/adjusted_frameTime.mat')['adjusted_frameTime'] #48x130
frame_time = pd.DataFrame(frametime)
print(frame_time.shape)

fixationCrossTime = scipy.io.loadmat('/content/resultMatrix.mat')['resultMatrix']
fixationcross_time = pd.DataFrame(fixationCrossTime)
fixationcrosstime = pd.DataFrame(fixationcross_time)

fixationcrosstime

#trialtime = scipy.io.loadmat('/content/trialTime.mat')['trialTime'] #1x130

m = loadmat('trialTime.mat', squeeze_me=True)
raw = m['trialTime']


session_list = []
for i in range(raw.size):
    arr = np.array(raw[i]).ravel()
    if len(arr) < 48:
        arr = np.pad(arr, (0, 48 - len(arr)), constant_values=np.nan)
    session_list.append(arr)

# 3) DataFrame / NumPy array
time_data = np.column_stack(session_list)  # (48, 130)

print(time_data.shape)   # (48, 130)

#xposition_data = sio.loadmat('xPositionData.mat')['xPosition']  # (1, 130)

m = sio.loadmat('xPositionData.mat', squeeze_me=True)
raw_x = m['xPosition']  # (1, 130) cell array


xposition_list = []
for i in range(raw_x.size):
    arr = np.array(raw_x[i]).ravel()
    if len(arr) < 48:
        arr = np.pad(arr, (0, 48 - len(arr)), constant_values=np.nan)
    xposition_list.append(arr)


eye_data = np.column_stack(xposition_list)
print(eye_data.shape)  # (trial, session)

"""##Defining Threshold"""

#middle of the screen 960

lower_threshold = 860
upper_threshold = 1060

s = 100    # session index (0–129)
t = 11    # trial index       (0–47)

eye_vec  = eye_data[t, s]
time_vec = time_data[t, s]

plt.figure(figsize=(8,6))
plt.plot(time_vec, eye_vec, label='X-Position', color='blue')
plt.axhline(lower_threshold, color='red', linestyle='--', label='Lower Threshold')
plt.axhline(upper_threshold, color='red', linestyle='--', label='Upper Threshold')

plt.xlabel('Time (ms)')
plt.ylabel('X Position (px)')
plt.title(f'Session {s+1}, Trial {t+1}')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

s = 2    # session index (0–129)
t = 11    # trial index       (0–)

# veriler
eye_vec     = eye_data[t, s]    # X-pozisyon
time_vec    = time_data[t, s]   # time (ms)
frame_onset = frame_time.iloc[t, s]  # frame onset (ms)

# plot
plt.figure(figsize=(8,6))
plt.plot(time_vec, eye_vec, label='X-Position',  color='blue')


plt.axhline(lower_threshold, color='red',   linestyle='--', label='Lower Threshold')
plt.axhline(upper_threshold, color='red',   linestyle='--', label='Upper Threshold')

# frame onset
plt.axvline(frame_onset, color='green', linestyle='--', label='Frame Onset')

plt.xlabel('Time (ms)')
plt.ylabel('X Position (px)')
plt.title(f'Session {s+1}, Trial {t+1}')
plt.legend()
plt.grid(True)
plt.tight_layout()
plt.show()

"""#First Fixation Calculation"""

# --- Parameters ---
velocity_threshold = 12       # px/ms
stability_threshold = 30      # px
window_size = 20
screen_center = 960
margin = 100
lower_threshold = screen_center - margin
upper_threshold = screen_center + margin

n_trials, n_sessions = eye_data.shape
fixation_start_times = np.full((n_trials, n_sessions), np.nan)
fixation_end_times   = np.full((n_trials, n_sessions), np.nan)
missing_fixations    = []

for s in range(n_sessions):        #  (session)
    for t in range(n_trials):      #  (trial)
        x = eye_data[t, s]         # (X-Position)
        times = time_data[t, s]    # (Time)
        onset_time = picture_time.iloc[t, s]  # Picture onset


        if x is None or times is None or np.isnan(onset_time):
            missing_fixations.append((s, t))
            continue

        # Picture onset
        onset_idx = np.nanargmin(np.abs(times - onset_time))

        vel = np.abs(np.diff(x))
        saccade_detected = False
        first_fix_start = None

        # --- find first fixation ---
        for i in range(onset_idx + 20, len(x) - window_size):
            if not saccade_detected:

                if vel[i-1] > velocity_threshold and (x[i] < lower_threshold or x[i] > upper_threshold):
                    saccade_detected = True
                continue

            # Stability
            window = x[i : i + window_size]
            vel_window = vel[i : i + window_size - 1]
            if (np.nanmax(window) - np.nanmin(window) <= stability_threshold) and np.all(vel_window < velocity_threshold):
                if x[i] < lower_threshold or x[i] > upper_threshold:
                    first_fix_start = times[i + window_size // 2]
                    break

        if first_fix_start is None:
            missing_fixations.append((s, t))
            continue

        # --- Fixation End ---
        idx0 = np.nanargmin(np.abs(times - first_fix_start))
        direction_left = x[idx0] < screen_center
        last_stable = None
        first_fix_end = None

        for j in range(idx0 + window_size, len(x)):
            win = x[max(0, j-window_size):j]
            vel_win = vel[max(0, j-window_size):j-1]
            if len(win) == window_size and (np.nanmax(win) - np.nanmin(win) <= stability_threshold):
                last_stable = times[j - window_size // 2]

            if np.any(vel_win > velocity_threshold) and (
                (direction_left and x[j] > lower_threshold) or
                (not direction_left and x[j] < upper_threshold)
            ):
                first_fix_end = last_stable if last_stable is not None else times[j-1]
                break

        if first_fix_end is None:
            first_fix_end = times[-1]

        # --- Save ---
        fixation_start_times[t, s] = first_fix_start
        fixation_end_times[t, s]   = first_fix_end

# --- .mat  ---
sio.savemat("fixationStartTimes_strict_48x130.mat", {"fixationStartTimes": fixation_start_times})
sio.savemat("fixationEndTimes_strict_48x130.mat",   {"fixationEndTimes":   fixation_end_times})

print(f"Total fixation not found: {len(missing_fixations)}")

missing_readable = [(s + 1, t + 1) for t, s in missing_fixations]
missing_df = pd.DataFrame(missing_readable, columns=['Session', 'Trial'])

missing_df

def plot_first_fixation(session_number, trial_number):
    """
    session_number: 1-based (1…130)
    trial_number:   1-based (1…48)
    eye_data:       np.array shape=(48,130)
    time_data:      np.array shape=(48,130)
    picture_time:   pd.DataFrame shape=(48,130)
    fixation_start_times, fixation_end_times: np.array shape=(48,130)
    """
    # Thresholds
    lower_threshold = screen_center - margin
    upper_threshold = screen_center + margin


    s = session_number - 1
    t = trial_number  - 1


    x_data = eye_data[t, s]
    t_data = time_data[t, s]
    frame_onset = frame_time.iloc[t, s]
    fix_start = fixation_start_times[t, s]
    fix_end   = fixation_end_times[t, s]

    plt.figure(figsize=(12, 5))
    plt.plot(t_data, x_data, color='black', label='X Position')

    # Picture onset
    if not np.isnan(frame_onset):
        plt.axvline(frame_onset, color='green', linestyle='--', label='Frame Onset')


    plt.axhline(lower_threshold, color='red', linestyle='--', label='Lower Threshold')
    plt.axhline(upper_threshold, color='red', linestyle='--', label='Upper Threshold')

    # Fırst Fıxatıon
    if not np.isnan(fix_start) and not np.isnan(fix_end):

        si = np.nanargmin(np.abs(t_data - fix_start))
        ei = np.nanargmin(np.abs(t_data - fix_end))

        plt.plot(t_data[si:ei+1],
                 x_data[si:ei+1],
                 color='blue', linewidth=2,
                 label='First Fixation')

        plt.axvline(fix_start, color='purple', linestyle='--', label='Fixation Start')
        plt.axvline(fix_end,   color='orange', linestyle='--', label='Fixation End')
        title = f"Session {session_number}, Trial {trial_number} – First Fixation"
    else:
        title = f"Session {session_number}, Trial {trial_number} – No fixation detected"

    plt.title(title)
    plt.xlabel("Time (ms)")
    plt.ylabel("X Position (pixels)")
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

plot_first_fixation(session_number= 3, trial_number=12)

if 'fixation_start_times' not in locals() or 'fixation_end_times' not in locals():
    print("Error: The string 'fixation_start_times' or 'fixation_end_times' was not found.")
    print("Run this code after the fixation detection loop has run.")
else:
    # Get the dimensions directly from the shape of the 'fixation_start_times' array
    num_trials, num_sessions = fixation_start_times.shape


    data_for_df = []

    #
    for trial_idx in range(num_trials):
        for session_idx in range(num_sessions):
            #
            start_time = fixation_start_times[trial_idx, session_idx]
            end_time = fixation_end_times[trial_idx, session_idx]

            #
            data_for_df.append({
                'session': session_idx + 1,
                'trial': trial_idx + 1,
                'fixation_start_time': start_time,
                'fixation_end_time': end_time
            })

    # --- 2. Create DataFrame ---
    fixation_times_df = pd.DataFrame(data_for_df)

fixation_times_df

"""#First Fixation to Action Time"""

#Step 1
# calculate first fixation as  ms for that we have to take picture onset as a startes point. Formula = first fixation - picture onset
#Step 2
# calculate frame onset as a ms. formula = frame onset - picture onset

records = []

for _, row in fixation_times_df.iterrows():
    sid = int(row['session'])               # 1-based session
    trial = int(row['trial'])               # 1-based trial
    fix_start = row['fixation_start_time']
    fix_end = row['fixation_end_time']

    # 0-based indexing
    frame_onset   = frame_time.iloc[trial-1, sid-1]
    picture_onset = picture_time.iloc[trial-1, sid-1]

    # If there is fixation first_fix_ms (fix-start – picture-onset)
    if not np.isnan(fix_start):
        first_fix_ms = fix_start - picture_onset
    else:
        first_fix_ms = np.nan

    #fixation end
    if not np.isnan(fix_end) and not np.isnan(picture_onset):
        fixation_end_ms = fix_end - picture_onset
    else:
        fixation_end_ms = np.nan

    # picture – frame farkı
    if not np.isnan(picture_onset) and not np.isnan(frame_onset):
        frame_time_ms = frame_onset - picture_onset
    else:
        frame_time_ms = np.nan

    records.append({
        'session': sid,
        'trial': trial,
        'picture_onset_time': picture_onset,
        'frame_onset_time':   frame_onset,
        'fixation_start_time': fix_start,
        'fixation_end_time':   fix_end,
        'first_fix_ms':        first_fix_ms,
        'fixation_end_ms': fixation_end_ms,
        'frame_time_ms':       frame_time_ms
    })


first_fix_ms_df = pd.DataFrame(records)

first_fix_ms_df

#Step 3
# convert reaction time sec to ms

df = rt_time.reset_index().rename(columns={'index': 'trial'})


long_df = df.melt(id_vars='trial',
                  var_name='session',
                  value_name='reaction_time_sec')


long_df['trial'] = long_df['trial'] + 1
long_df['session'] = long_df['session'].astype(int) + 1


reactiontime_df = (
    long_df[['session', 'trial', 'reaction_time_sec']]
    .assign(reaction_time_ms=lambda df: (df.reaction_time_sec * 1000).round(1))
)

reactiontime_df

#Step 4
# Combining reaction time and fixation ms and frame ms data

fix_cols = ['session', 'trial', 'first_fix_ms','fixation_end_ms', 'frame_time_ms']
rt_cols  = ['session', 'trial', 'reaction_time_ms']


final_df = (
    first_fix_ms_df[fix_cols]
    .merge(
        reactiontime_df[rt_cols],
        on=['session', 'trial'],
        how='inner'
    )
)


final_df['reaction_time_real_ms'] = final_df['frame_time_ms'] + final_df['reaction_time_ms']

final_df = final_df[['session', 'trial',
                     'first_fix_ms','fixation_end_ms',
                     'frame_time_ms', 'reaction_time_ms',
                     'reaction_time_real_ms']]

final_df

#Step 5
#calculate to first fixation to action based on that formula :reaction_time_real_ms - first_fix_ms
#reaction time based on the frame onset time that's why we have to calculate that

final_df['first_fixation_to_action'] = final_df['reaction_time_real_ms'] - final_df['first_fix_ms']

final_df

#Step 6
# add valence, side, condition veribles

reaction_long = (
    reactiontype_df
      .reset_index()
      .rename(columns={'index':'trial0'})
      .melt(
        id_vars='trial0',
        var_name='session0',
        value_name='reaction_type'
      )
)
reaction_long['trial']   = reaction_long['trial0'].astype(int) + 1
reaction_long['session'] = reaction_long['session0'].astype(int) + 1
reaction_long['reaction_type'] = reaction_long['reaction_type'].apply(
    lambda x: x[0] if isinstance(x, (list, np.ndarray)) and len(x) > 0 else np.nan
)
reaction_long = reaction_long[['session', 'trial', 'reaction_type']]

# --- 2) valence_df ---
valence_long = (
    valence_df
      .reset_index()
      .rename(columns={'index':'trial0'})
      .melt(
        id_vars='trial0',
        var_name='session0',
        value_name='valence'
      )
)
valence_long['trial']   = valence_long['trial0'].astype(int) + 1
valence_long['session'] = valence_long['session0'].astype(int) + 1
valence_long = valence_long[['session', 'trial', 'valence']]

# --- 3) side_looked  ---
side_records = []
for _, row in fixation_times_df.iterrows():
    sid = int(row['session'])
    trial = int(row['trial'])
    fix_start = row['fixation_start_time']

    side_looked = np.nan
    if not np.isnan(fix_start):
        eye_vec = eye_data[trial-1, sid-1]
        time_vec = time_data[trial-1, sid-1]
        if eye_vec is not None and time_vec is not None:
            fix_start_idx = np.nanargmin(np.abs(time_vec - fix_start))
            x_at_fixation = eye_vec[fix_start_idx]
            if x_at_fixation < screen_center:
                side_looked = 'left'
            elif x_at_fixation > screen_center:
                side_looked = 'right'

    side_records.append({'session': sid, 'trial': trial, 'side': side_looked})

side_long = pd.DataFrame(side_records)

# --- 4) framecolor_df (0=ORANGE, 1=BLUE) ---
framecolor_long = (
    framecolor_df
      .reset_index()
      .rename(columns={'index': 'trial0'})
      .melt(
          id_vars='trial0',
          var_name='session0',
          value_name='frame_color'
      )
)
framecolor_long['trial']   = framecolor_long['trial0'].astype(int) + 1
framecolor_long['session'] = framecolor_long['session0'].astype(int) + 1
framecolor_long = framecolor_long[['session', 'trial', 'frame_color']]

# --- 5) final_df’e  ---
final_df = (
    final_df
      .merge(valence_long,    on=['session', 'trial'], how='left')
      .merge(reaction_long,   on=['session', 'trial'], how='left')
      .merge(side_long,       on=['session', 'trial'], how='left')
      .merge(framecolor_long, on=['session', 'trial'], how='left')
)

# --- 6) condition ---
def assign_condition(row):
    if pd.isna(row['valence']) or pd.isna(row['reaction_type']):
        return np.nan
    # positive (1) pull = congruent
    if row['valence'] == 1:
        return 'congruent' if row['reaction_type'] == 'pull' else 'incongruent'
    # negative (0) push = congruent
    if row['valence'] == 0:
        return 'congruent' if row['reaction_type'] == 'push' else 'incongruent'
    return np.nan

# for implicit task
#if pd.isna(row['frame_color']) or pd.isna(row['reaction_type']):
        #return np.nan
    # ORANGE (0) → Pull = congruent, Push = incongruent
    #if row['frame_color'] == 0:
        #return 'congruent' if row['reaction_type'] == 'pull' else 'incongruent'
    # BLUE (1) → Push = congruent, Pull = incongruent
    #if row['frame_color'] == 1:
        #return 'congruent' if row['reaction_type'] == 'push' else 'incongruent'
    #return np.nan

final_df['condition'] = final_df.apply(assign_condition_from_frame, axis=1)

final_df

#Apply log 10 format for firt_fix_to_action and clean negative values
final_df["log10_first_fixation_to_action"] = np.log10(final_df["first_fixation_to_action"] + 1)

final_df

def plot_tff(session, trial):
    """
    session: 1-based index (1–130)
    trial:   1-based index (1–48)
    """
    s_idx = session - 1
    t_idx = trial - 1

    # Gaze and time
    x_data = eye_data[t_idx, s_idx]
    t_data = time_data[t_idx, s_idx]
    if x_data is None or t_data is None:
        print("Bu session/trial için gaze verisi bulunamadı.")
        return


    frame_onset = frame_time.iloc[t_idx, s_idx]
    fix_start = fixation_start_times[t_idx, s_idx]
    fix_end = fixation_end_times[t_idx, s_idx]

    # Reaction time
    reaction_row = final_df[
        (final_df['session'] == session) &
        (final_df['trial'] == trial)
    ]
    if not reaction_row.empty:
        behavioral_reaction_time = frame_onset + reaction_row['reaction_time_ms'].values[0]
    else:
        behavioral_reaction_time = None

    # Plot
    plt.figure(figsize=(10, 5))
    plt.plot(t_data, x_data, color='black', label='X Position')


    if not np.isnan(fix_start) and not np.isnan(fix_end):
        s_idx_fix = np.nanargmin(np.abs(t_data - fix_start))
        e_idx_fix = np.nanargmin(np.abs(t_data - fix_end))
        plt.plot(t_data[s_idx_fix:e_idx_fix+1], x_data[s_idx_fix:e_idx_fix+1],
                 color='blue', linewidth=2, label='First Fixation')

    # Thresholds
    plt.axhline(lower_threshold, color='red', linestyle='--', label='Lower Threshold')
    plt.axhline(upper_threshold, color='red', linestyle='--', label='Upper Threshold')

    # Frame onset
    plt.axvline(frame_onset, color='green', linestyle='--', label='Frame Onset')

    # Fixation start and end
    if not np.isnan(fix_start):
        plt.axvline(fix_start, color='purple', linestyle='--', label='Fixation Start')
    if not np.isnan(fix_end):
        plt.axvline(fix_end, color='orange', linestyle='--', label='Fixation End')

    # Behavioral reaction time
    if behavioral_reaction_time is not None and not np.isnan(behavioral_reaction_time):
        plt.axvline(behavioral_reaction_time, color='blue', linestyle='-', label='Behavioral Reaction')

    # plot
    plt.title(f'Session {session}, Trial {trial}')
    plt.xlabel('Time (ms)')
    plt.ylabel('X Position (pixels)')
    plt.legend()
    plt.grid(True)
    plt.tight_layout()
    plt.show()

plot_tff(1, 1)

#data elemenating depents on experiment

#1. elemenate invalid sessions 69, 70, 107, 108 for exp 1

#2. elemenate fixation start after reaction time

#NEGATIVE FTA VALUES
# Fixation end'in reaction time'dan sonra bittiği satırlar
negatives1 = final_df[final_df['reaction_time_real_ms'] - final_df['first_fix_ms'] < 0]

print(f"Toplam {len(negatives1)} trial fixation start, finished AFTER the reaction.")

neg_mask1 = final_df['reaction_time_real_ms'] - final_df['first_fix_ms'] < 0
final_df.loc[neg_mask1, :] = np.nan

print(f"Toplam {neg_mask1.sum()} Trial fixation start finished AFTER reaction and NaN was made.")

#3. elemenate fixation end trials continuing after the reaction

negatives2 = final_df[final_df['reaction_time_real_ms'] - final_df['fixation_end_ms'] < 0]

print(f"Toplam {len(negatives2)} trial fixation END, finished AFTER reaction.")

# make nan first fixations end after reaction time

#neg_mask2 = final_df['reaction_time_real_ms'] - final_df['fixation_end_ms'] < 0

# 2) Bu satırları NaN yap
#final_df.loc[neg_mask2, :] = np.nan

# 3) Kontrol: Kaç satır NaN oldu
#print(f"Toplam {neg_mask2.sum()} trial fixation END, reaction'dan SONRA bitmiş ve NaN yapıldı.")

final_df

final_df.to_csv("final_df1.csv", index=False)

final = ['session', 'trial', 'first_fixation_to_action', 'valence','side', 'condition', 'log10_first_fixation_to_action']

fta_final = final_df[final].copy()

fta_final

# Drop any row that contains a NaN value
fta_final = fta_final.dropna().reset_index(drop=True)

#disturbution of first fix to action

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(fta_final['first_fixation_to_action'], bins=80, kde=True, color='blue')
plt.title("First Fixation to Action Distribution")
plt.xlabel("First Fixation to Action (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(fta_final['log10_first_fixation_to_action'], bins=80, kde=True, color='green')
plt.title("Log10 First Fixation to Action Distribution")
plt.xlabel("Log10(First Fixation to Action)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

fta_above_3 = fta_final[fta_final['first_fixation_to_action'] > 5000] #frame matching problems

print(fta_above_3.shape)
fta_above_3

for _, row in fta_above_3.iterrows():
    session = int(row['session'])
    trial = int(row['trial'])
    print(f"Plotting Session {session}, Trial {trial}")
    plot_tff(session, trial)   #frame matching problems

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(fta_final['first_fixation_to_action'], bins=80, kde=True, color='blue')
plt.title("First Fixation to Action Distribution")
plt.xlabel("First Fixation to Action (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(fta_final['log10_first_fixation_to_action'], bins=80, kde=True, color='green')
plt.title("Log10 First Fixation to Action Distribution")
plt.xlabel("Log10(First Fixation to Action)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

fta_final

# --- Add Participant column ---
sessions_per_participant = 2  # 2 session = 1 participant
ffd_final['participant'] = ((ffd_final['session'] - 1) // sessions_per_participant) + 1


new_records = []
num_participants = ffd_final['participant'].nunique()

for pid in range(1, num_participants + 1):

    participant_data = ffd_final[ffd_final['participant'] == pid]

    # Sessionları and trial
    participant_data = participant_data.sort_values(by=['session', 'trial']).reset_index(drop=True)


    participant_data['trials'] = range(1, len(participant_data) + 1)

    new_records.append(participant_data)


ffd_df = pd.concat(new_records, ignore_index=True)

fta_final_df = fta_df[["participant","trials","first_fixation_to_action","log10_first_fixation_to_action", "side", "valence","condition"]].copy()

fta_final_df

# Effective coding

# Apply effect coding
fta_final_df["valence"] = fta_final_df["valence"].map({
    0 : -1, #negative
    1 : 1 #positive
})

fta_final_df["condition"] = fta_final_df["condition"].map({
    "incongruent": -1,
    "congruent": 1
})

fta_final_df["side"] = fta_final_df["side"].map({
    "left": -1,
    "right": 1
})

#Clean nan values

# Drop any row that contains a NaN value
fta_ready = fta_final_df.dropna().reset_index(drop=True)

# Optional: display result
fta_ready

# --- Histograms ---
plt.figure(figsize=(12,5))

plt.subplot(1, 2, 1)
sns.histplot(fta_ready['first_fixation_to_action'], bins=80, kde=True, color='blue')
plt.title("First Fixation to Action Distribution")
plt.xlabel("First Fixation to Action (ms)")
plt.ylabel("Frequency")

plt.subplot(1, 2, 2)
sns.histplot(fta_ready['log10_first_fixation_to_action'], bins=80, kde=True, color='green')
plt.title("Log10 First Fixation to Action Distribution")
plt.xlabel("Log10(First Fixation to Action)")
plt.ylabel("Frequency")

plt.tight_layout()
plt.show()

sns.barplot(data=fta_ready, x="valence", y="first_fixation_to_action", ci="sd")
plt.title("FTA by Emotional Valence")
plt.xlabel("Emotional Valence (-1: Negative, 1: Positive)")
plt.ylabel("First Fixation to Action (ms)")
plt.show()

sns.barplot(data=fta_ready, x="side", y="first_fixation_to_action", ci="sd")
plt.title("FTA by Side ")
plt.xlabel("Side (-1: left, 1: right)")
plt.ylabel("First Fixation to Action (ms)")
plt.show()

sns.barplot(data=fta_ready, x="condition", y="first_fixation_to_action", ci="sd")
plt.title("FTA by condition ")
plt.xlabel("Condition (-1: incongruent, 1: congruent)")
plt.ylabel("First Fixation to Action (ms)")
plt.show()

import pandas as pd

# Her değişken için ayrı ayrı mean ve std
summary_condition = fta_ready.groupby("condition")["first_fixation_to_action"].agg(["mean","std"])
summary_side      = fta_ready.groupby("side")["first_fixation_to_action"].agg(["mean","std"])
summary_valence   = fta_ready.groupby("valence")["first_fixation_to_action"].agg(["mean","std"])

print("Condition bazında:")
print(summary_condition, "\n")

print("Side bazında:")
print(summary_side, "\n")

print("Valence bazında:")
print(summary_valence)

import seaborn as sns
import matplotlib.pyplot as plt


fta_ready_plot = fta_ready.copy()
fta_ready_plot["valence"] = fta_ready_plot["valence"].map({-1: "Negative", 1: "Positive"})
fta_ready_plot["side"] = fta_ready_plot["side"].map({-1: "Left", 1: "Right"})
fta_ready_plot["condition"] = fta_ready_plot["condition"].map({-1: "Incongruent", 1: "Congruent"})

# Violin Plot: valence x log10_fta, hue = side, col = condition
g = sns.catplot(
    data=fta_ready_plot,
    x="valence", y="first_fixation_to_action",
    hue="side", col="condition",
    kind="violin",
    split=True, inner="quartile",
    palette={"Left": "skyblue", "Right": "salmon"},
    height=5, aspect=1
)

g.set_axis_labels("Valence", " First Fixation to Action")
g.set_titles("Condition: {col_name}")
g.add_legend(title="Side")
plt.suptitle("Violin Plot of First Fixation to Action(ms))", fontsize=14, y=1.05)
plt.tight_layout()
plt.show()

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt


plot_df = fta_ready.copy()
plot_df["Valence"]   = plot_df["valence"].map({-1: "Negative", 1: "Positive"})
plot_df["Side"]      = plot_df["side"].map({-1: "Left", 1: "Right"})
plot_df["Condition"] = plot_df["condition"].map({-1: "Incongruent", 1: "Congruent"})

# 2) Condition × Valence × Side
agg = (plot_df
       .groupby(["Condition", "Valence", "Side"])["first_fixation_to_action"]
       .agg(["mean", "count", "std"])
       .reset_index())
agg["sem"] = agg["std"] / np.sqrt(agg["count"].replace(0, np.nan))

# =============== FIGURE A: Interaction (mean ± 95% CI) ===============
conditions = ["Congruent", "Incongruent"]
x_levels = ["Positive", "Negative"]
sides = ["Left", "Right"]

for cond in conditions:
    fig = plt.figure(figsize=(6,4))
    ax = plt.gca()

    for side in sides:
        sub = agg[(agg["Condition"]==cond) & (agg["Side"]==side)].set_index("Valence").reindex(x_levels)
        y = sub["mean"].values
        yerr = 1.96 * sub["sem"].values  # ~95% CI
        x = np.arange(len(x_levels))

        ax.errorbar(x, y, yerr=yerr, marker="o", linestyle="-", label=side)

    ax.set_title(f"First Fixation to Action — {cond}")
    ax.set_xticks(np.arange(len(x_levels)))
    ax.set_xticklabels(x_levels)
    ax.set_xlabel("Valence")
    ax.set_ylabel("First Fixation to Action (ms)")
    ax.legend(title="Side")
    ax.grid(True, alpha=0.3)
    plt.tight_layout()
    plt.show()

groups = {
    "Right-Positive": (fta_ready["side"] == 1) & (fta_ready["valence"] == 1),
    "Right-Negative": (fta_ready["side"] == 1) & (fta_ready["valence"] == -1),
    "Left-Positive": (fta_ready["side"] == -1) & (fta_ready["valence"] == 1),
    "Left-Negative": (fta_ready["side"] == -1) & (fta_ready["valence"] == -1)
}


summary_df = pd.DataFrame(columns=["Group", "Mean", "Std"])


for name, condition in groups.items():
    subset = fta_ready.loc[condition, "first_fixation_to_action"]
    mean_val = subset.mean()
    std_val = subset.std()
    summary_df = pd.concat([summary_df, pd.DataFrame({
        "Group": [name],
        "Mean": [mean_val],
        "Std": [std_val]
    })], ignore_index=True)


print(summary_df)

groups = {}
for side_label, side_val in [("Right", 1), ("Left", -1)]:
    for valence_label, valence_val in [("Positive", 1), ("Negative", -1)]:
        for cond_label, cond_val in [("Congruent", 1), ("Incongruent", -1)]:
            group_name = f"{side_label}-{valence_label}-{cond_label}"
            condition_mask = (
                (fta_ready["side"] == side_val) &
                (fta_ready["valence"] == valence_val) &
                (fta_ready["condition"] == cond_val)
            )
            groups[group_name] = condition_mask

# Mean and Std
summary_df = pd.DataFrame(columns=["Group", "Mean", "Std", "Count"])

for name, mask in groups.items():
    subset = fta_ready.loc[mask, "first_fixation_to_action"]
    mean_val = subset.mean()
    std_val = subset.std()
    count_val = subset.count()
    summary_df = pd.concat([summary_df, pd.DataFrame({
        "Group": [name],
        "Mean": [mean_val],
        "Std": [std_val],
        "Count": [count_val]
    })], ignore_index=True)


print(summary_df)

import matplotlib.pyplot as plt
import numpy as np


x_levels = ["Positive", "Negative"]
conditions = ["Congruent", "Incongruent"]
sides = ["Left", "Right"]
colors = {"Left":"#1f77b4","Right":"#ff7f0e"}
linestyles = {"Congruent":"-","Incongruent":"--"}

fig, ax = plt.subplots(figsize=(7,5))

for cond in conditions:
    for side in sides:
        sub = agg[(agg["Condition"]==cond) & (agg["Side"]==side)].set_index("Valence").reindex(x_levels)
        y = sub["mean"].values
        yerr = 1.96*sub["sem"].values  # 95% CI
        x = np.arange(len(x_levels))

        ax.errorbar(
            x, y, yerr=yerr,
            marker="o",
            linestyle=linestyles[cond],
            color=colors[side],
            label=f"{side}-{cond}"
        )

ax.set_xticks(np.arange(len(x_levels)))
ax.set_xticklabels(x_levels)
ax.set_xlabel("Valence")
ax.set_ylabel("First Fixation to Action (ms)")
ax.set_title("First Fixation to Action by Condition, Valence, and Side")
ax.legend(title="Side-Condition")
ax.grid(True, alpha=0.3)
plt.tight_layout()
plt.show()

"""#LMM"""

import statsmodels.api as sm
from statsmodels.formula.api import mixedlm

log10_model = mixedlm(
    "log10_first_fixation_to_action ~ side * valence * condition",
    data=fta_ready,
    groups=fta_ready["participant"],
    re_formula="~side"
)

log10_result = log10_model.fit(reml=False)
print(log10_result.summary())
print(f"\nAIC: {log10_result.aic:.2f}")
print(f"BIC: {log10_result.bic:.2f}")

log10_residuals = log10_result.resid
log10_fitted = log10_result.fittedvalues

# Histogram
sns.histplot(log10_residuals, kde=True, bins=50)
plt.title('Distribution of Residuals (Log10 Model)')
plt.xlabel('Residuals')
plt.tight_layout()
plt.show()

# Q-Q Plot
sm.qqplot(log10_residuals, line='s')
plt.title('Q-Q Plot of Residuals (Log10 Model)')
plt.tight_layout()
plt.show()